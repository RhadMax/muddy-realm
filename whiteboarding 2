so if a player's position were tracked in the memory of the server, it wouldn't need to interact with the database's players table at every move.

ways to have all players location update in real time:
    *have position tracked as a value in player table, and at every interval of play a select query is sent asking the server to return all players(and mobs, if that is being tracked also?) that have that same position value, then list them as being present in that position. any time player moves the position value in the players table would need to get updated, and then the table would need to get queried again for that position.

    *have position tracked as a variable in memory on server(or index.js whatever it may be) and then only update it to the database every so often, either as a value on player table or as a value in locations table... would not work for real time updates on multiple player locations in that case... if we want real time updates then the memory needs to be tracking all active players locations, which actually might still work fairly well....
        --expanding on this, player makes new char, create variable for player using constructor in script, that character is now 'online' in server code by existing in memory as a variable in the player{}, nested in the activePlayers[], and each player{} includes a location value. as other characters either make new chars or 'load' characters into play, they also become 'online' by being added to the memory of the running server as indexes of the players array. When they log out, that player is removed from the array and their data is stored in the players database.
        
        -- To cover server crash scenarios it would be wise to include a rollback/failsafe type feature which saves all players data in the sql database at certain time intervals, or maybe even every so often based on number of commands inputted by user (ie a counter variable that exists in each player's object, counts up with each action and at 10 or 20, or 50 who knows, gets set back to 0 and a update query is sent to the database for that player so no one ever loses too much progress in the event of a server crash or somehow otherwise untracked player 'logout'.) This would also benefit from having a timeout after any action inputted that will automatically log out a character that takes no action for an extended period of time.

        --this keeps memory use minimal for players while also allowing us quickly accesible data for logic actions like evaluating all players that are currently in a certain position. Sooo, player moves, their position keyed value updates within their player{}, players array is looped to show others who are there, (is this risky? lotta evaluations performed if many are online, as each player would result in a loop sorting through all online players and returning results every time they move---idea to help with this would be having multiple onlineplayer arrays, one for each region of the world. players{} could have another key that tells the server which array to sort through. updating that region key might be tricky... maybe 32x32 grids for each region for mapping purposes, or 1024 tiles per region, and if ).

    *have location table (or tables?) also have a column for tracking players currently occupying that location, so when data for flavor text is fetched upon moving it also returns a list of those present. In order for this to stay real time every single movement of any player/mob would need to update set, and then select from tables where position = that position. In fact, that would involve two subsequent update set queries back to back, one to remove the unit from the position it's moving from and one to update the position it's moving into to contain it, then the select to return who is currently there. I have a feeling this method would be the least efficient, since it would involve making multiple queries to what will invariably be the largest table of data.


    ***location table, just use x and y as two columns, third column can be a boolean of is it passable, then fourth column can be "content"... VARCHAR 255 with flavor text for each tile that is passable=true, or just a small snippet of text if false to tell user what blocks their path (ie fence, boulder, house wall), first part of any movement input will be doing a select from SQL table where col1 (x) and col2(y) = the new player.x and player.y. If that query returns a true for passable then char position is updated and the data from sql prints out for new location that player is in. If query returns false for that new tile instead, then player does not move, and the data from the query is used to populate the message to user "You cannot move this way, a <obstacle> blocks your path." ... maybe also 5th column with players? but then we're querying that tabel with a select and an update on every move... and that will be the only value on this table that is mutable, better to keep this as a read-only table. Perhaps another table, with the same exact x,y columns, and that table can be queried with an update and the resulting data can be used to generate a list of other units in that position. Without the extra columns for blocked or not and no flavor text this position reference table would run faster and wouldn't risk losing flavor text data. Also it wouldn't need ALL positions, just those with true for passable off of the positions-text table.

Inventory and char management via saves:: Will initially try to have it so that the players table in the SQL DB holds all data, but suspect that it may make sense ot split it up eventually, so that there is a table for equipment, table for inventory, table for statuses... each with a foreign key tying it to the right character from the players table. If player table doesn't get too big I suppose it may work fine to use JSON data types for status/skills/equipment/inventory all within the players table but am unsure as of now how well that will work.
    *after reading about tables in sql a bit, it seems common practice to get around using arrays, and as many seem to think is better than using JSON data types in sql, is using seperate tables and referencing them by foreign keys, as I hinted above. This stackoverflow post had some nice examples: https://stackoverflow.com/questions/17371639/how-to-store-arrays-in-mysql
    So it may make sense to have a few tables, one for each array that a player needs (players_inventory, players_equipment, players_skills, players_status), and another table for each thing that needs defining [inventory/equip could share the one 'items' table where the item 'objects' are defined by columns corresponding to object keys and values for that item]. The player id is referenced in those player_*tables whenever data is needed from those tables (really just on load/save?). 

    --clarifying: there's an items table to define all items as objects, and ANOTHER table for player_items that has a row for each instance of any item a player has, each of those rows with two columns of foreign keys, one to tie it to the player by the players primary ID, and then the column representing what item it is, as a foreign key, that is tied to the item's primary key ID from the main table of items. So when loading the query can pull a select from all 3 using an inner join, and populate an array of objects (default of how the response comes; each row is an object), where each key is equal to the columns as defined in the items table, and filtering by player id overlapping with the foreign key player id will not only specify that the correct items held by that player be returned, but also the quantity as there may be duplicate items. (phewww that's a mouthful)

    for status table it could really just be a table with more columns, and just one row per player. Each column is a status effect and the value is just a boolean. This creates a complication if the effect is time-duration based... which I imagine some things would be, but that may just have to suffer for now untill I think of a solution that is better, and if it does fade over time that time will only work outside the scope of saving, aka loading a saved file with a status effect on it will reset that duration timer since that timer will likely only track in the active memory. (quick idea, use integers instead of boolean for the effects with duration, and the code could read like (while player.status.poison > 0) { hp --}...somehow tied to the global tick of time.

    skills table could operate in much the same way as status, a wide table holding all skills as columns (decimal(5,2)), each row a player tied by id. 